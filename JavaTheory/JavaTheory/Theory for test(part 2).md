JDBC
	6.1 Драйверы соединения, запросы
		Java database connectivity - стандартный прикладной интерфейс языка Java для организации взаимодействия между приложением и СУБД. Взаимодействие осуществляется с помощью драйверов JDBC, обеспечивающих реализацию общих интерфейсов для конкретных СУБД и конкретных протоколов.
		Последовательность действий:
		1) подключение библиотеки с классом-драйвером базы данных.
		2) Установка соединения с БД.
		Для установки соединения с БД вызывается один из перегруженных методов getConnection() класса java.sql.DriverManager.
		3)Создание объекта для передачи запросов.
		Statement, PreparedStatement, CallableStatement
		4) Выполнение запроса.
		Созданный объект Statement можно использовать для выполнения запросов SQL, передавая их в один из методов.
		execute() - произвольный запрос;
		executeUpdate() - запрос изменения данных в базе данных( create, delete, update)
		executeQuery() - запросы Select, выборка.
		executeBatch() - выполняет Batch-команды, т.е. группу запросов, как один запрос.
		5) Обработка результатов запроса на выборку данных (ResultSet)
		6)закрытие соединения
		7)выгрузка драйверов
	6.4 Метаданные
			Интерфейсы ResultSetMetaData и DatabaseMetaData.
			С помощью этих интерфейсов можно получить список таблиц, определить типы, свойства и количество столбцов БД.
			ResultSetMetaData:
			int getColumnCount() - возвращает число столбцов набора результатов объекта ResultSet;
			String getColumnName(int column) - возвращает имя указанного столбца;
			String getColumnTypeName(int column) - возвращает тип данных указанного столбца.
		DataBaseMetaData:
			String getDatabaseProductName() - возвращает название СУБД;
			String getDatabaseProductVersion() - номер версии СУБД;
			String getDriverName() - имя драйвера JDBC;
			String getUserName() - имя пользователя БД;
			String getURL() - местонахождение источника данных;
			ResultSet getTables() - набор типов таблиц, доступных для данной БД.
		6.5 Подготовленные запросы и хранимые процедуры
			PreparedStatement, CallableStatement
			Пример хранимой процедуры
			CREATE DEFINER=`root`@`localhost` PROCEDURE `findlastname`(IN p_phone INT, OUT p_lastname VARCHAR(40)) BEGIN SELECT lastname INTO p_lastname FROM phonebook WHERE phone = p_phone; END
		6.6 Транзакции
			Транзакция или деловая операция, определяется как единица работы, обладающая свойствами ACID:
			- Атомарность - две или более операций, выполняются все или не выполняется ни одна;
			-Согласованность - при возникновении сбоя система возвращается в состояние до начала неудавшейся транзакции.
			-Изолированность - во время выполнения транзакции все объекты-сущности, участвующие в ней, должны быть синхронизированы.
			-долговечность - все изменения, произведенные с данными во время транзакции, обязательно сохраняются, например в базе данных, что позволяет восстанавливать систему.
		6.8 Repository and Specification
		Repository - предоставляет интерфейс взаимодействия с данными в виде коллекции не обращая внимание на реализацию.
		Specification - позволяет предъявлять цепочку требований к объектам. (Predicate)
XML & Java
	10.1 Инструкция по обработке
		XML-документ может содержать инструкции по обработке, которые используются для передачи информации в работащее с ним приложение.
		<?xml-stylesheet type="text/xsl" href="student.xsl"?>
		Инструкция "student.xls"
		Комментарии.
		<!-- -->
		Указатели на зарезервированные символы &символ;
		Корректность XML-документа определяют следующие два компонента: — синтаксическая корректность (well-formed), то есть соблюдение всех синтаксических правил XML; — действительность (valid), то есть данные соответствуют некоторому набору правил, определенных пользователем; правила определяют структуру и формат данных в XML. Валидность XML-документа определяется наличием DTD или XML-схемы (XSD) и соблюдением правил, которые там приведены.
	10.2 DTD
		CDATA
		Пример:
		<data><[!CDATA[ 5 < 7 ]]></data>
		DTD определяет, какие теги (элементы) могут использоваться в XMLдокументе, как эти элементы связаны между собой (например, указывать на то, что элемент включает дочерние элементы, какие атрибуты имеет тот или иной элемент. Это позволяет наложить четкие ограничения на совокупность используемых элементов, их структуру, вложенность.
		Для описания структуры XML-документа используется язык описания DTD (Document Type Definition). В настоящее время DTD практически не используется и повсеместно замещается XSD.
	10.3 XSD
		Схема XSD представляет собой более строгое, чем DTD, руководство по созданию и валидации XML-документа. XSD-схема, в отличие от DTD, является XML-документом, и поэтому она отличается гибкостью при использовании  в приложениях, при задании правил документа, а также для дальнейшего расширения новой функциональностью. В отличие от DTD схема содержит большое количество базовых типов(44 типа) и имеет поддержку пространств имен. С помощью XSD можно также проверить документ на корректность, а именно валидность.
		Схема XSD первой строкой содержит XML-декларацию. Любая схема своим корневым элементом должна содержать элемент schema.
		В схеме нужно описать все элементы: их тип, количество повторений, дочерние элементы. Сам элеиент создается элементом element, который может включать атрибуты:
		-name - определить имя элемента;
		-type - определить тип элемента;
		-ref - ссылается на определение элемента, находящегося в другом месте;
		-minOccurs, maxOccurs - количество повторений этого элемента;(unbounded).
	10.4 Простые и сложные типы.
		Существует стандартные простые типы(string, boolean, integer, float, ID, gYear...).
		Также простые типы можно создавать на основе существующих типов посредством элемента simpleType. Атрибут name содержит имя типа.
		Атрибут base указывает основной тип, а в элемент restriction можно включить ряд ограничений.
		<simpleType name="Login">
			<restriction base="ID">
 				<pattern value="(\\w){8, 20}"/>
			</restriction>
		</simpleType>
		Сложные типы, элементы содержащие в себе атрибуты и/или дочерние элементы.
		Сложные элементы создаются с помощью элемента complexType.
		Для указания, что элементы внутри описываемого сложного типа должны располагаться в определенной последовательности, используются элементы sequence, all, choice. Также в сложных типах можно создавать атрибуты. Для указания, обязан ли использоваться атрибут можно использовать атрибут use, которые принимает значения required, optional, prohibited. Для установки значения по умолчанию, используется атрибут default, а для фиксированного значения - атрибут fixed.
		<complexType name="Student">
			<sequence>
 				<element name="name" type="string"/>
				 <element name="telephone" type="positiveInteger"/>
 				<element name="address" type="tns:Address"/>
			</sequence>
			<attribute name="login" type="tns:Login" use="required"/>
			<attribute name="faculty" type="string" use="optional"/>
		</complexType>
	10.5 JAXP
		JAXP - java API for XML processing. XML-докумет как набор байт в памяти, запись в базе или текстовый файл представляет собой данные, которые еще предстоит обработать. То есть из набора строк получить данные, пригодные длая использования. Для этого существуют универсальные средства обработки XML-анализаторы.
	10.6 Валидирующие и невалидирующие анализаторы
		Как было уже упомянуто, существуют два вида корректности XML-документа: синтаксическая (well-formed) — документ сформирован в соответствии с синтаксическими правилами построения— и действительная (valid)— документ синтаксически корректен и соответствует требованиям, заявленным в XSD. Соответственно, есть невалидирующие и валидирующие анализаторы. И те, и другие проверяют XML-документ на соответствие синтаксическим правилам. XML & JAVA  Но только валидирующие анализаторы знают, как проверить XML-документ на соответствие структуре, описанной в XSD. Никакой связи между видом анализатора и видом XML-документа нет. Валидирующий анализатор может разобрать XML-документ, для которого нет XSD, и, наоборот, невалидирующий анализатор может разобрать XMLдокумент, для которого есть XSD. При этом он просто не будет учитывать описание структуры документа
	10.7 Древовидная и псевдособытийная модели
		Существует три подхода к обработке XML-документов:
		- DOM (Document Object Model) -платформенно-независимый программный интерфейс, позволяющий программам и скриптам управлять содержимым документов HTML и XML, а также изменять их структуру и оформление. Модель DOM не накладывает ограничений на структуру документа. Любой документ известной структуры с помощью DOM может быть представлен в виде дерева узлов, каждый узел которого содержит элемент, атрибут, текстовый, графический или любой другой объект. Узлы связаны между собой отношениями родитель-потомок.
		- SAX(Simple API for XML) базируется а модели последовательной одноразовой обработки и не создает внутренних деревьев. При прохождении по XML вызывает соответствующие методы у классов, реализующих интерфейсы, предоставляемые SAX-парсером.
		-StAX(Streaming API for XML) не создает дерево объектов в памяти, но, в отличие от SAX-парсера, за переход от одной вершины XML к другой отвечает приложение, которое запускает разбор документа.
		```java
		package by.bsy.saxsimple; 
		import org.xml.sax.helpers.DefaultHandler; import org.xml.sax.Attributes;
		public class SimpleStudentHandler extends DefaultHandler { 
			@Override 
			public void startDocument() { 			System.out.println("Parsing started"); 
			} 
			@Override 
			public void startElement(String uri, String localName, String qName, Attributes attrs) { 
				String s = localName; 
				// получение и вывод информации об атрибутах элемента 
				for (int i = 0; i < attrs.getLength(); i++) { 
					s += " " + attrs.getLocalName(i) + "=" + attrs.getValue(i);  
				} 
				System.out.print(s.trim()); 
			} 
			@Override 
			public void characters(char[ ] ch, int start, int length) { 
				System.out.print(new String(ch, start, length)); 
			} 
			@Override 
			public void endElement(String uri, String localName, String qName) { 
				System.out.print(localName); 
			} 
			@Override 
			public void endDocument() { 												   System.out.println("\nParsing ended"); 
			} 
		}
		```	
Servlet
	11.1 Запуск контейнера сервлетов и размещение проекта
		Каждому клиенту сервлет выделяет независимый поток выполнения. Клиент посылает приложению HTTP-запрос, сервлет генерирует ответ и возвращает его клиенту в виде html-документа.
		/bin — содержит файлы запуска монитора и контейнера сервлетов вида tomcat.exe, tomcatw.exe и некоторые необходимые для этого библиотеки; /lib — содержит библиотеки служебных классов, в частности Servlet API и JSP API; используемые внешние библиотеки (если они есть), упакованные в JAR-файлы; /conf — содержит конфигурационные файлы, в частности, конфигурационный файл сервера server.xml; /logs — в этот каталог записываются log-файлы, инициированные сервером; /webapps — в этот каталог помещаются папки с веб-приложениями, содержащие в свою очередь сервлеты и другие компоненты конкретного приложения.
		В каталог /webapps необходимо поместить папку /FirstProject с вложенным в нее сервлетом FirstServlet. Кроме того, папка /FirstProject должна содержать каталог /WEB-INF, в котором помещаются подкаталоги: /classes — содержит class-файл сервлета by.bsu.first.servlet.FirstServlet; /src — содержит исходный файл сервлета FirstServlet.java (опционально); а также web.xml — дескриптор доставки (развертывания) приложения располагается в каталоге /WEB-INF.
	11.2 
		Жизненный цикл сервлета начинается с его инициализации и загрузки в память контейнером сервлетов при старте контейнера либо в ответ на первый клиентский запрос. Сервлет готов к обслуживанию любого числа запросов. Завершение существования происходит при выгрузке его из контейнера
	11.3 Взаимодействие сервлета и страницы
		Страницы JSP и сервлеты никогда не следует использовать в информационных системах друг без друга. Причиной являются принципиально различные роли, которые играют данные компоненты в приложении. Страница JSP ответственна за формирование пользовательского интерфейса и отображение информации, переданной с сервера. Сервлет выполняет роль контроллера запросов и ответов, то есть принимает запросы от всех связанных с ним JSP-страниц, вызывает соответствующую бизнес-логику для их (запросов) обработки и в зависимости от результата выполнения решает, какую JSP поставить этому результату в соответствие. При необходимости расширения функциональности системы не следует создавать дополнительные сервлеты. Сервлет в приложении должен быть один. При создании нового учебного приложения во избежание путаницы всегда следует создавать новый проект. Для демонстрации взаимодействия JSP-страниц и сервлета будет решена задача определения времени между загрузкой страницы в браузер и нажатием кнопки на этой же странице.
		Обмен информацией между JSP и сервлетом чаще всего осуществляется с помощью атрибутов объектов HttpServletRequest, HttpSession, HttpServletContext.
	11.4 Интерфейсы
		ServletContext 
			Каждому приложению ставится в соответствие единственный экземпляр, ассоциированный с контейнером сервлетов, реализующий ServletContext. Контекст выполнения сервлета предоставляет средства для общения с application сервером и позволяет получать информацию о среде выполнения, а также использовать ресурсы совместно с другими объектами приложения. В частности, можно добавить/извлечь/удалить атрибуты, извлечь параметры контекста или записать информацию в log-файл. Получить ссылку на объект ServletContext можно вызовом метода getServletContext() на экземпляре сервлета.
			Экземпляр ServletContext может применяться для обмена информацией между сервлетами приложения. Но в большей части промышленных приложений СЕРВЛЕТЫ применяется односервлетная модель, поэтому использовать объект контекста следует только для хранения информации о конфигурации приложения или общей информации для всех клиентов.
		ServletConfig
			Параметры инициализации сервлета содержатся в экземпляре ServletConfig. Получить доступ к нему можно методом getServletConfig(), вызываемым на экземпляре сервлета
		HttpServletRequest
			Информация от клиента веб-приложения отправляется серверу в виде объекта запроса типа HttpServletRequest. Данный интерфейс является производным от интерфейса ServletRequest. Используя методы интерфейса ServletRequest, можно получить: информацию о сервлете, доступ к сессии и параметрам запроса, управление атрибутами и кодировками, а также детали протокола HTTP.
		HttpServletResponse
			Генерируемые сервлетами данные пересылаются серверу-контейнеру с помощью объектов, реализующих интерфейс ServletResponse, а сервер, в свою очередь, формирует и пересылает ответ клиенту, инициировавшему запрос.
		11.7 Сессия, события, фильтры, Cookie
			Сеанс есть сессия между клиентом и сервером, устанавливаемая на определенное время, за которое клиент может отправить на сервер сколько угодно запросов. Сеанс устанавливается непосредственно между клиентом и веб-сервером в момент получения первого запроса к веб-приложению. Каждый клиент устанавливает с сервером свой собственный сеанс, который сохраняется до окончания работы с приложением.
			Для хранения информации на компьютере клиента используются возможности класса javax.servlet.http.Cookie.
			Cookie — это небольшие блоки текстовой информации, которые сервер посылает клиенту для сохранения в файлах cookies. Клиент может запретить браузеру прием файлов cookies. Браузер возвращает информацию обратно на сервер как часть заголовка HTTP, когда клиент повторно заходит на тот же веб-ресурс. Cookies могут быть ассоциированы не только с сервером, но и также с доменом; в этом случае браузер посылает их на все серверы указанного домена. Этот принцип лежит в основе одного из протоколов обеспечения единой идентификации пользователя (Single Signon), где серверы одного домена обмениваются идентификационными маркерами (token) с помощью общих сookies
			Обработка событий
			— javax.servlet.ServletContextListener — обрабатывает события создания/ удаления контекста сервлета; 
			— javax.servlet.ServletContextAttributeListener — обрабатывает события создания/удаления/модификации атрибутов контекста сервлета; 
			— javax.servlet.http.HttpSessionListener — обрабатывает события создания/ удаления HTTP-сессии; 
			— javax.servlet.http.HttpSessionAttributeListener — обрабатывает события создания/удаления/модификации атрибутов HTTP-сессии;
			— javax.servlet.http.HttpSessionBindingListener — обрабатывает события привязывания/разъединения объекта с атрибутом HTTP-сессии;
			— javax.servlet.http.HttpSessionActivationListener — обрабатывает события, связанные с активацией/деактивацией HTTP-сессии; 
			— javax.servlet.ServletRequestListener — обрабатывает события создания/ удаления запроса; 
			— javax.servlet.ServletRequestAttributeListener — обрабатывает события создания/удаления/модификации атрибутов запроса сервлета
JSP
	12.1 JSP
		В то время как сервлеты наилучшим образом подходят для выполнения контролирующей функции приложения в виде обработки запросов и определения содержания и вида ответа, страницы JSP выполняют функцию отображения результатов работы приложения в виде текстовых документов типа HTML, XML, WML и некоторых других. JSP поддерживают как JavaScript, так и HTML-теги. JavaScript обычно используется, чтобы добавить функциональные возможности на уровне HTML-страницы. Принято разделять динамическое и статическое содержимое JSP. Динамические ресурсы. Результаты их деятельности изменяются во время выполнения приложения. Обычно представлены в виде выражений Expression Language, библиотек тегов и тегов разработчика. Статические ресурсы. Не изменяются сами в процессе работы (HTML, JavaScript, изображения и т. д.). Смысл разделения динамического и статического содержания в том, что статические ресурсы могут находиться под управлением HTTP-сервера в то время, как динамические нуждаются в движке (JSP Engine) и в большинстве случаев в доступе к уровню данных. Рекомендуется разделить и разрабатывать параллельно две части приложения: часть, состоящяя только из динамических ресурсов, и часть, состоящяя только из статических ресурсов. Некоторые преимущества использования JSP-технологии над другими методами создания динамического содержания страниц: — разделение динамического и статического содержания. Возможность разделить логику приложения и дизайн веб-страницы снижает сложность разработки веб-приложений и упрощает их поддержку;
		— независимость от платформы. Технологии Java не зависят от платформы, следовательно, JSP могут выполняться практически на любом веб-сервере. Разрабатывать JSP можно на любой платформе; — многократное использование компонентов. Использование JavaBeans и Enterprise JavaBeans (EJB) позволяет многократно использовать компоненты, что ускоряет создание веб-приложений; — теги. Спецификация JSP содержит библиотеку стандартных тегов JSTL, позволяет разработчику создавать собственные теги, кроме того, теги обеспечивают возможность использования JavaBean и обращение к классам бизнес-логики
		Жизненный цикл Процессы, выполняемые с файлом JSP при первом вызове: — браузер делает запрос к странице JSP; — JSP-engine анализирует содержание файла JSP и создает сервлет с кодом, основанным на исходном тексте файла JSP, при этом engine транслирует статическое содержимое в методы вывода и помещает его в метод _jspService(). Полученный сервлет будет ответственен за генерацию статических элементов, определенных во время разработки. Динамические элементы транслируются в java-код; — код сервлета компилируется в файл *.class. и загружается в контейнер. В итоге сервлет на основе JSP установлен и готов к работе; — выполняется метод init() сервлета; — вызываeтся метод _jspService(), и сервлет логически исполняется, формируя экземпляр response; — комбинация статического HTML и графики вместе с результатами исполнения динамических элементов, определенных в оригинале JSP, пересылаются браузеру через выходной поток объекта ответа HttpServletResponse.
		Большинство стандартных тегов, содержащих символ %, в современном программировании не применяются. Используются action-теги версии JSP 2.0. Они позволяют создавать правильные JSP — документы. В тоже время декларации, выражения и скриптлеты остаются под негласным запретом из-за явного внедрения java-кода в JSP. Action-теги: —  — позволяет включать статические и динамические ресурсы в контекст генерируемой страницы при запросе вида — Включаемая страница не может объявлять собственные заголовки, определяющие тип или кодировку; 
		— <jsp:declaration> — (нежелателен) объявление, аналогичен тегу <%! %>; 
		— <jsp:scriplet>— (нежелателен) скриптлет, аналогичен тегу <% %>; 
		— <jsp:exspression> — (нежелателен) выражение, аналогичен тегу <%= %>; 
		— <jsp:text>— вывод текста; 
		— <jsp:useBean>— объявление экземпляра компонента Java Bean или класса, обладающего public-конструктором по умолчанию. Если экземпляр с указанным идентификатором не существует, то он будет создан в области видимости scope со значением page (страница), request (запрос), session (сессия) или application (приложение). Объявляется, как правило, с атрибутами id (имя объекта), class (полное имя класса), type (по умолчанию class).
		— <jsp:getProperty> — извлекает значения поля указанного объекта, преобразует его в строку и отправляет в неявный объект out. 
		— <jsp:forward> — позволяет передать запрос другой странице или сервлету. 
		— <jsp:plugin> — замещается тегом или  в зависимости от типа браузера, в котором будет выполняться подключаемый апплет или Java Bean; 
		— <jsp:params> — группирует параметры внутри тега jsp:plugin; 
		— <jsp:param> — добавляет параметры в объект запроса, например, в элементах forward, include, plugin; 
		— <jsp:fallback>  — указывает содержимое, которое будет использоваться браузером клиента, если подключаемый модуль не сможет запуститься. Используется внутри элемента plugin.
		Элементы <jsp:attribute>, <jsp:body>, <jsp:invoke>, <jsp:doBody>, <jsp:element>, <jsp:output> используются, в основном, при включении в страницу пользовательских тегов и библиотек тегов.
	 12.2 Типы EL операторов
		== (или eq), != (или ne), < (или lt), > (или gt), <= (или le), >= (или ge). Арифметические операторы: +, -, *, / (или div), % (или mod). Логические операторы: && (или and), || (или or), ! (или not).
		Оператор empty используется для проверки значения переменной на null, или «пустое значение». Термин «пустое значение» зависит от типа проверяемого объекта. Это понятие включает нулевую длину для строки или нулевой размер для коллекции или массива.
	12.3
		При выполнении веб-приложений, как и любых других, могут возникать ошибки и исключительные ситуации. Возникает вопрос об их обработке. Если исключение в java-коде не обрабатывается, то оно попадает в контейнер сервлетов и получает код 500 с генерацией сообщения вида «500 Internal Server Error». Возникает также при вызове сервлетом метода sendError(500) на объекте HttpServletResponse. Такие действия производятся, как правило, для исключений времени выполнения. Исключения, генерируемые веб-приложением и не перехватываемые фильтром, сервлетом или JSP. При отсутствии запрашиваемой страницы генерируется ошибка с кодом 404. При запрете доступа — код 403. При отсутствии ответа сервера в течение определенного времени — код 504. При передаче слишком длинной строки запроса — код 414. Для обработки исключений в зависимости от типа в приложении могут использоваться обычные JSP-страницы, специальные JSP для обработки ошибок или HTML-страницы. Для настройки соответствия ошибок и обработчиков используется элемент error-page файла web.xml. Например, для обработки ошибки по коду: 404 /errors/error404.jsp
		<error-page>
			<error-code>404</error-code>
			<location>/errors/error404.jsp</location>
		</error-page>
		или 
		<error-page>
			<exception-type>javax.el.PropertyNotFountException</exception-type>
			<location>/errors/error_runtime.jsp</location>
		</error-page>
	12.4
		В большинстве приложений используются не сервлеты или JSP по отдельности, а их архитектурное взаимодействие. Страница JSP представляет вид для результатов выполнения запроса клиента, а сервлет отвечает за вызов классов бизнес-логики и передачу результатов выполнения бизнес-логики в соответствующую JSP и ее вызов. Т.е. сервлеты не генерируют ответа сами, а только выступают в роли контроллера запросов. Такая архитектура построения приложений носит название MVC (Model/View/Controller). Model — классы бизнес-логики и длительного хранения, View — страницы JSP, Controller — сервлет
	12.6 JSTL
		jsp standart tag libruary
		Состоит из 5 групп:
		core - основные теги,
		formatting - теги форматирования,
		sql - для работы с sql,
		xml - для обработки xml,
		functions - функции-теги для обработки строк.
		JSTL предоставляет следующие возможности:
		— поддержку Expression Language, что позволяет разработчику писать простые выражения внутри атрибутов тега и предоставляет «прозрачный» доступ к переменным в различных областях видимости страницы; 
		— организацию условных переходов и циклов, основанную на тегах, а не на скриптовом языке;
		— простое формирование доступа (URL) к различным ресурсам; 
		— простую интернационализацию JSP;
		— взаимодействие с базами данных (не рекомендуется);
		— обработку XML;
		— форматирование и разбор строк посредством библиотеки функций
		
I/o Streaam
	8.1 Потоки данных
		При разработке приложения регулярно возникает необходимость ввода информации из какого-либо источника и хранения результатов. Действия по чтению/записи информации представляют собой стандартный вид деятельности, связанный с передачей и извлечением последовательности байтов из потоков. Все потоки ввода последовательности байтов являются подклассами абстрактного класса InputStream, потоки вывода — подклассами абстрактного класса OutputStream. При работе с файлами используются подклассы этих классов, соответственно, FileInputStream и FileOutputStream, конструкторы которых открывают поток и связывают его с соответствующим физическим файлом. Существуют классы-потоки для ввода массивов байтов, строк, объектов, а также для выбора данных из файлов и сетевых соединений. 
		 
		