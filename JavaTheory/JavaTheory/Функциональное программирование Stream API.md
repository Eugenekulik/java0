Методы Default и Static в интерфейсах
	В Java 8 разрешено объявлять неабстрактные и статические методы в интерфейсах. Интерфейсы по-прежнему могут содержать абстрактные методы.
	При реализации классом такого интерфейса реализуются только абстрактные методы, default-методы могут переопределяться при необходимости.
	Статический метод вызывается классическим способом, без реализации содержащего его интерфейса.
	Появление методов по умолчанию в интерфейсах разрешило множественное наследование поведения.
Функциональные интерфейсы
	Функциональный интерфейс должен иметь один единственный абстрактный метод и любое число статических и default-методов. Для объявления такого интерфейса используется аннотация @FunctionalInterface. Интерфейс помеченный этой аннотацией предполагает его использование в виде лямбда-выражения.
Predicate<T> представляет метод boolean test(T t), возвращающий булево значенрие в зависимости от выполнения условия на объекте типа T. Основная область применени: выбор, поиск, фильтраци элементов из stream или коллекции по условию.
Function, основной абстрактный метод R apply(T t) принимает объект типа T и возвращает объект типа R.
Consumer<T> представлет абстрактный метод void accept(T t), функция, принимающая объект типа T и выполняющая над ним некоторое действие. Результат действия можно сохранить во внешнем объекте, например, коллекции или вывести в поток вывода., например, в файл или на консоль.
Supplier<T> возвращает новый объект типа T методом T get(). Предназначен для создания новых объектов. 
Comparator<T>, начиная с версии Java 8, приобрел свойства функционального интерфейса. Реализация интерфейса представляет возможность его использования для сортировки наборов объектов конкретного типа по правилам, определенным для этого типа. Метод int compare(T o1, T o2).
Замыкания
	Блок кода, представляющий собой лямбда-выражение вместе со значениями локальных переменных и параметров метода, в котором он объявлен, называется замыканием, или closure. Объект-функция создается во время исполнения, и применен может быть уже посел того как объект, его создавший, прекратит существование. 
Ссылки на методы
	Белее короткая запись лямбда-вырадения возможна в случае, если реализации функционального интерфейса необходимо передать существующий метод без всяких изменени.
Stream API
	С появлением Java 8 Stream API позволило программистам писать существенно короче то, что раньше занимало много строк кода, а именно - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.
	Возможные способы создания Stream:
		- Пустой стрим: Stream.empty();
		- Стрим из List: list.stream();
		- Стрим из Map: map.entrySet().stream();
		- Стрим из массива: Arrays.stream(array);
		- Стрим из указанных элементов: Stream.of(....).
	Операторы можно разделить на две группы:
		- Промежуточные - обрабатывают поступающие элементы и возвращают стрим. Промежуточных операторов в цепочке обработки элементов может быть много.
		- Терминальные - обрабатывают элементы и завершают работу стрима, так что терминальный оператор в цепочке может быть только один.
	Виды промежуточных операторов:
		 - filter(Predicate predicate) фильтрует стрим, пропуская только те элементы, что проходят по условию.
		- map(Function mapper) дает возможность создать функцию с помощью которой мы будем изменять каждый элемент и пропускать его дальше.
		- flatMap(Function<T, Stream<r>> mapper)
			как в случае с map, служат для преобразования в примитивный стрим, отличается тем что может возвращать стрим, и потом объединять все стримы в один.
		- limit(long maxSize) - ограничивает стрим по количеству элементов:
		- skip(long n) - пропускает n элементов.
		- sorted(), sorted(Comparator comparator) - сортировка.
		- distrinct() - проверяет стрим на уникальность элементов.
		- dropWhile(Predicate predicate) -пропускает элементы которые удовлетворяют условию.
	Виды терминальных операторов:
		- forEach(Consumer action) - аналог for each.
		- count() - возвращает количество элементов стрима:
		- collect(Collector collector) - метод собирает все элементы в список, множество или другую коллекцию, сгруппировывает элементы по какому-нибудь критерию, объединяет всё в строку и т.д.
		- reduce(T identity, BinaryOperator  accumulator) - преобразовывает все элементы стрима в один объект(посчитать сумму всех элементов, либо найти минимальный элемент), сперва берется объект identity и первый элемент стрима, применяется функция accumulator и udentity становится её результатом. Затем по новой.
		- Optional min(Comparator comparator) ищет минимальный элемент основываясь на comparator.
		- findFirst() - вытаскивает первый элемент стрима.
		- allMatch(Predicate predicate) - возвращает true, если все элементы стрима удовлетворяют условию.
		- anyMatch(Predicate predicate) - вернет true, если хотя бы один элемент стрима удовлетворяет условию.
		- noneMatch(Predicate predicate) - ни один.
		