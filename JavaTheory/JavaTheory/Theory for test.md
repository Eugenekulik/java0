1.1
Data types
1.1.1
History Java
Объектно-ориентированный язык Java, разработанный в компании Sun Microsystems в 1995 году для оживления графики на стороне клиента с помощью апплетов, в настоящее время используется для создания переносимых на различные платформы и операционные системы программ. Язык Java нашел широкое применение в Интернет-приложениях, добавив на статические и клиентские веб-страницы динамическую графику, улучшив интерфейсы и реализовав вычислительные возможности. Но объектно-ориентированная парадигма и кроссплатформенность привели к тому, что уже буквально через несколько лет после создания язык практически покинул клиентские страницы и перебрался на серверы. На стороне клиента его место заняли языки JavaScript, Adobe Flash и проч. При создании язык Java предполагался более простым, чем его синтаксический предок С++. Сегодня с появлением новых версий возможности языка Java существенно расширились и во многом перекрывают функциональность С++. Java уже не уступает по сложности предшественникам и называть его простым нельзя. Отсутствие указателей (наиболее опасного средства языка С++) нельзя считать сужением возможностей, а тем более — недостатком, это просто требование безопасности. Возможность работы с произвольными адресами памяти через безтиповые указатели позволяет игнорировать защиту памяти. Отсутствие в Java множественного наследования легко заменяется на более понятные конструкции с применением интерфейсов. Системная библиотека классов языка Java содержит классы и пакеты, реализующие и расширяющие базовые возможности языка, а также сетевые средства, взаимодействие с базами данных, графические интерфейсы и многое другое. Методы классов, включенных в эти библиотеки, вызываются JVM (Java Virtual Machine) во время интерпретации программы.
1.1.2
Область применения Java
-   Приложения для рабочего стола (десктопные) с графическим интерфейсом ...
-   Мобильные приложения ...
-   Встроенные системы ...
-   Веб-приложения ...
-   Веб-серверы и серверы приложений ...
-   Корпоративные (общеорганизационные) системы ...
-   Технологии больших данных ...
-   Научные приложения
1.1.3
Использование памяти. Жизненный цикл программы
В Java все объекты программы расположены в динамической памяти — куче данных (heap) и доступны по объектным ссылкам, которые, в свою очередь, хранятся в стеке (stack). Это решение исключило непосредственный доступ к памяти, но усложнило работу с элементами массивов и сделало ее менее эффективной по сравнению с программами на C++. В свою очередь, в Java предложен усовершенствованный механизм работы с коллекциями, реализующими основные динамические структуры данных. Необходимо отметить, что объектная ссылка языка Java содержат информацию о классе объекта, на который она ссылается, так что объектная ссылка — это не указатель, а дескриптор (описание) объекта. Наличие дескрипторов позволяет JVM выполнять проверку совместимости типов на фазе интерпретации кода, генерируя исключение в случае ошибки. В Java изменена концепция организации динамического распределения памяти: отсутствуют способы программного освобождения динамически выделенной памяти. Вместо этого реализована система автоматического освобождения памяти (сборщик мусора), выделенной с помощью оператора new. Программист может только рекомендовать системе освободить выделенную динамическую память.
1.1.4
Компиляция и запуск приложения из командной строки. Работа с аргументами командной строки
 Простейшие примеры
Простейший способ компиляции — вызов строчного компилятора из корневого каталога, в котором находится каталог by, каталог bsu и так далее: javac by/bsu/simple/action/SloganAction.java javac by/bsu/simple/run/FirstProgram.java При успешной компиляции создаются файлы FirstProgram.class и SloganAction.class, имена которых совпадают с именами классов. Запустить этот байткод можно с помощью интерпретатора Java: java by.bsu.simple.run.FirstProgram Здесь к имени приложения FirstProgram.class добавляется путь к пакету от корня проекта by.bsu.simple.run, в котором он расположен. Чтобы компилировать и выполнить приложение, необходимо загрузить и установить последнюю версию пакета, например по адресу: http://www.oracle.com/technetwork/java/javase/downloads/ При инсталляции рекомендуется указывать для размещения корневой каталог. Если JDK установлена в директории (для Windows) c:\Java\jdk7, то каталог, который компилятор Java будет рассматривать как корневой для иерархии пакетов, можно вручную задавать с помощью переменной среды окружения в виде: СLASSPATH=.;c:\Java\jdk7\. Переменной задано еще одно значение «.» для использования текущей директории, например, с:\workspace в качестве рабочей для хранения своих собственных приложений. Чтобы можно было вызывать сам компилятор и другие исполняемые программы, переменную PATH нужно проинициализировать в виде PATH=c:\Java\jdk7\bin. ВВЕДЕНИЕ В ООП И КЛАССЫ 19 Этот путь указывает на месторасположение файлов javac.exe и java.exe. В различных версиях операционных систем путь к JDK может указываться различными способами. Однако при одновременном использовании нескольких различных версий компилятора и различных библиотек применение переменных среды окружения начинает мешать эффективной работе, так как при выполнении приложения поиск класса осуществляется независимо от версии. Когда виртуальная машина обнаруживает класс с подходящим именем, она его и подгружает. Такая ситуация предрасполагает к ошибкам, порой трудноопределимым. Поэтому переменные окружения начинающим программистам лучше не определять вовсе.
1.1.5
Консоль.
1.2
Varaibles & operators
1.2.1
Примитивные типы. Размер типа данных
1.2.2
Объявление переменных. Зарезервированные слова. Литералы
1.2.3
Преобразование типов
1.2.4
Классы-оболочки. Big-классы. Упаковка/распаковка
1.2.5
Статический импорт
1.2.6
Операторы
1.2.7
Операторы управления. If, циклы, switch
1.2.8
Ссылочные типы данных
1.3
Простейшие классы и объекты
1.3.1
Опрделения. Свойства и методы. Конструкторы. Пакеты.
1.4
Arrays
1.4.1
Определения. Объявление и инициализация. Массив массивов
1.4.2
Работа с массивами
1.5
Code conventions
1.5.1
Именование пакетов, классов, методов, переменных, констант
1.5.2
Оформление циклов и операторов управления
1,6
Generic
1.6.1
Назначение и синтаксис
1.6.2
Использование extends
1.6.3
Метасимвол
1.6.4
Параметризированные методы
1.6.5
Ограничения и применение
1.7
enums
1.7.1
Синтаксис и определения. Создание объектов перечисления. Методы перечисления
1.7.2
Конструкторы и анонимные классы для перечисления. Сравнение
1,8
Inner Classes
1.8.1
Inner (нестатические)
1.8.2
Nested (статические)
1.8.3
Анонимные (Anonymous) классы
1.9
Документирование кода
OOP
2.1
Причины возникновения ООП
2.1.1
Развитие языков и парадигм программирования
2.1.2
Причины возникновения и задачи ООП
2.2
Классы и объекты
2.2.1
Понятия объект, класс, экземпляр класса
2.2.2
Переменные класса, константы, спецификаторы доступа, области видимости
2.2.3
Конструкторы, ключевые слова new, this и super. Метод finalize()
2.2.4
Методы классов, сигнатура методов, передача параметров в метод. Явные и неявные параметры метода (this)
2.2.5
Статические методы и поля, модификаторы final и native
2.2.6
Блоки инициализации. Инициализация полей класса (порядок инициализации)
2.2.7
Перегрузка методов
2.2.8
Класс java.lang.Object. Методы этого класса.
2.2.9
Методы с переменным числом параметров
2.3
Принципы ООП
2.3.1
Абстракция и Инкапсуляция
2.3.2
Наследование
2.3.3
Полиморфизм (виды полиморфизма)
2.3.4
Механизм позднего связывания (overriding)
2.3.5
SOLID принципы
2.4
Наследование
2.4.1
Основные понятия
2.4.2
Переопределение методов
2.4.3
Вызов конструкторов при наследовании
2.4.4
Ссылки на суперкласс и их свойства. Действия, которые происходят при вызове метода, принадлежащего объекту. Предотвращение наследования с помощью модификатора final. Приведение типов при наследовании.
2.4.5
Абстрактные методы и классы.
2.4.6
Статические методы при наследовании
2.5
Interfaces
2.5.1
Назначение
2.5.2
Определение и реализация интерфейса
2.5.3
Свойства интерфейсов
2.5.4
Интерфейсы и обратные вызовы
2.5.5
Клонирование объектов. Интерфейс Clonable
2.5.6
Сравнение объектов. Интерфейс Comparable
Errors & exceptions
3.1
Понятие исключения
3.2
Основные принципы обработки исключений
3.3
Типы исключений
3,4
Использование операторов try и catch
3,5
Множественные операторы catch
3,6
Вложенные операторы try
3,7
Оператор throw и ключевое слово throws
3,8
Блок finally
3,9
Создание собственных исключений
3.9.1
Наследование классов Throwable и Exeption
3.9.2
Методы и конструкторы, определенные в Throwable и Exeption
3.10
Применение собственных исключений
Функциональные интерфейсы
Методы default и static в интерфейсах
Функциональные интерфейсы и лямбда-выражения
Интерфейс Predicate
Интерфейс Function
Интерфейс Consumer
Интерфейс Supplier
Интерфейс Comparator
Замыкания
Ссылки на методы
Stream API
Какие есть методы в интерфейсе Stream?
Чем отличается метод map от flatMap?
Какой функциональный интерфейс использует метод filter?
…
Threads
1. Multithreading
1.1. Понятие потока и процесса
1.2. Создание и запуск потоков. Класс Thread, интерфейсы Runnable, Callable
1.3. Методы класса Thread
1.4. Thread Lificycle
1.5. Состояния потока
1.6. Приоритетность потоков
2. Daemon threads
3. Threads & exceptions
4. Non blocking concurrency
4.1. volatile
4.2. Atomic
5. Synchronized
5.1. method wait
5.2. methods notify notifyAll
5.3. Monitor
5.4. Интерфейс Lock как альтернатива synchronized
5.5. Deadlock
6. Паралелльные утилиты
6.1. Semaphore
6.2. CyclicBarrier
6.3. CountDownLatch
6.4. BlockingQueue, BlockingDeque
6.5. Exchanger
6.6. Phaser
7. TimeUnit
8. ExecutorService и Механизм Fork\Join