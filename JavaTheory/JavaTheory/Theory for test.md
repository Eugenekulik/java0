1.1
Data types
1.1.1
History Java
Объектно-ориентированный язык Java, разработанный в компании Sun Microsystems в 1995 году для оживления графики на стороне клиента с помощью апплетов, в настоящее время используется для создания переносимых на различные платформы и операционные системы программ. Язык Java нашел широкое применение в Интернет-приложениях, добавив на статические и клиентские веб-страницы динамическую графику, улучшив интерфейсы и реализовав вычислительные возможности. Но объектно-ориентированная парадигма и кроссплатформенность привели к тому, что уже буквально через несколько лет после создания язык практически покинул клиентские страницы и перебрался на серверы. На стороне клиента его место заняли языки JavaScript, Adobe Flash и проч. При создании язык Java предполагался более простым, чем его синтаксический предок С++. Сегодня с появлением новых версий возможности языка Java существенно расширились и во многом перекрывают функциональность С++. Java уже не уступает по сложности предшественникам и называть его простым нельзя. Отсутствие указателей (наиболее опасного средства языка С++) нельзя считать сужением возможностей, а тем более — недостатком, это просто требование безопасности. Возможность работы с произвольными адресами памяти через безтиповые указатели позволяет игнорировать защиту памяти. Отсутствие в Java множественного наследования легко заменяется на более понятные конструкции с применением интерфейсов. Системная библиотека классов языка Java содержит классы и пакеты, реализующие и расширяющие базовые возможности языка, а также сетевые средства, взаимодействие с базами данных, графические интерфейсы и многое другое. Методы классов, включенных в эти библиотеки, вызываются JVM (Java Virtual Machine) во время интерпретации программы.
1.1.2
Область применения Java
-   Приложения для рабочего стола (десктопные) с графическим интерфейсом ...
-   Мобильные приложения ...
-   Встроенные системы ...
-   Веб-приложения ...
-   Веб-серверы и серверы приложений ...
-   Корпоративные (общеорганизационные) системы ...
-   Технологии больших данных ...
-   Научные приложения
1.1.3
Использование памяти. Жизненный цикл программы
В Java все объекты программы расположены в динамической памяти — куче данных (heap) и доступны по объектным ссылкам, которые, в свою очередь, хранятся в стеке (stack). Это решение исключило непосредственный доступ к памяти, но усложнило работу с элементами массивов и сделало ее менее эффективной по сравнению с программами на C++. В свою очередь, в Java предложен усовершенствованный механизм работы с коллекциями, реализующими основные динамические структуры данных. Необходимо отметить, что объектная ссылка языка Java содержат информацию о классе объекта, на который она ссылается, так что объектная ссылка — это не указатель, а дескриптор (описание) объекта. Наличие дескрипторов позволяет JVM выполнять проверку совместимости типов на фазе интерпретации кода, генерируя исключение в случае ошибки. В Java изменена концепция организации динамического распределения памяти: отсутствуют способы программного освобождения динамически выделенной памяти. Вместо этого реализована система автоматического освобождения памяти (сборщик мусора), выделенной с помощью оператора new. Программист может только рекомендовать системе освободить выделенную динамическую память.
1.1.4
Компиляция и запуск приложения из командной строки. Работа с аргументами командной строки
 Простейшие примеры
Простейший способ компиляции — вызов строчного компилятора из корневого каталога, в котором находится каталог by, каталог bsu и так далее: javac by/bsu/simple/action/SloganAction.java javac by/bsu/simple/run/FirstProgram.java При успешной компиляции создаются файлы FirstProgram.class и SloganAction.class, имена которых совпадают с именами классов. Запустить этот байткод можно с помощью интерпретатора Java: java by.bsu.simple.run.FirstProgram Здесь к имени приложения FirstProgram.class добавляется путь к пакету от корня проекта by.bsu.simple.run, в котором он расположен. Чтобы компилировать и выполнить приложение, необходимо загрузить и установить последнюю версию пакета, например по адресу: http://www.oracle.com/technetwork/java/javase/downloads/ При инсталляции рекомендуется указывать для размещения корневой каталог. Если JDK установлена в директории (для Windows) c:\Java\jdk7, то каталог, который компилятор Java будет рассматривать как корневой для иерархии пакетов, можно вручную задавать с помощью переменной среды окружения в виде: СLASSPATH=.;c:\Java\jdk7\. Переменной задано еще одно значение «.» для использования текущей директории, например, с:\workspace в качестве рабочей для хранения своих собственных приложений. Чтобы можно было вызывать сам компилятор и другие исполняемые программы, переменную PATH нужно проинициализировать в виде PATH=c:\Java\jdk7\bin. ВВЕДЕНИЕ В ООП И КЛАССЫ 19 Этот путь указывает на месторасположение файлов javac.exe и java.exe. В различных версиях операционных систем путь к JDK может указываться различными способами. Однако при одновременном использовании нескольких различных версий компилятора и различных библиотек применение переменных среды окружения начинает мешать эффективной работе, так как при выполнении приложения поиск класса осуществляется независимо от версии. Когда виртуальная машина обнаруживает класс с подходящим именем, она его и подгружает. Такая ситуация предрасполагает к ошибкам, порой трудноопределимым. Поэтому переменные окружения начинающим программистам лучше не определять вовсе.
1.1.5
Консоль.
1.2
Varaibles & operators
1.2.1
Примитивные типы. Размер типа данных
	Java - язык объектно-ориентированного программирования, однако не все данные в языке есть объекты. Для повышения производительности в нем кроме объектов используются базовые типы данных. значения которых размещаются в стековой памяти при компиляции программы. Для каждого базового типа имеются также обеъкты-оболочки, которые инкапсулируют данные базовых типов в объекты, располагаемые в динамической памяти(heap). Базовые типы обеспечивают более высокую производительность вычислений по сравнению с объектами классов-оболочек и другими объенктами.
	Определенно восемь базовых типов данных, размерт каждого из которых остается неизменным независимо от платформы.
	Беззнаковых типов в Java не существует. Каждый тип данных определяет множество значений и их представления в памяти. Для каждого типа определён набор операций над его значениями.
	В Java используются целочисленные литералы, например: 35 - целое десятичное число, 071 - восьмеричное число, 0x51b - шестнадцатеричное число, 0b1010 - двоичное число. Целочисленные литералы по умолчанию относятся к типу int. Если необходимо определить длинный литерал типа long, в конце указывается символ L. Если значение числа больше значения, помещается в int, то Java автоматически полагает, что оно типа long.
1.2.2
Объявление переменных. Зарезервированные слова. Литералы
1.2.3
Преобразование типов
1.2.4
Классы-оболочки. Big-классы. Упаковка/распаковка
1.2.5
Статический импорт
1.2.6
Операторы
1.2.7
Операторы управления. If, циклы, switch
1.2.8
Ссылочные типы данных
1.3
Простейшие классы и объекты
1.3.1
Опрделения. Свойства и методы. Конструкторы. Пакеты.
1.4
Arrays
1.4.1
Определения. Объявление и инициализация. Массив массивов
1.4.2
Работа с массивами
1.5
Code conventions
1.5.1
Именование пакетов, классов, методов, переменных, констант
1.5.2
Оформление циклов и операторов управления
1,6
Generic
1.6.1
Назначение и синтаксис
1.6.2
Использование extends
1.6.3
Метасимвол
1.6.4
Параметризированные методы
1.6.5
Ограничения и применение
1.7
enums
1.7.1
Синтаксис и определения. Создание объектов перечисления. Методы перечисления
1.7.2
Конструкторы и анонимные классы для перечисления. Сравнение
1,8
Inner Classes
1.8.1
Inner (нестатические)
1.8.2
Nested (статические)
1.8.3
Анонимные (Anonymous) классы
1.9
Документирование кода
OOP
2.1
Причины возникновения ООП
2.1.1
Развитие языков и парадигм программирования
2.1.2
Причины возникновения и задачи ООП
2.2
Классы и объекты
2.2.1
Понятия объект, класс, экземпляр класса
2.2.2
Переменные класса, константы, спецификаторы доступа, области видимости
2.2.3
Конструкторы, ключевые слова new, this и super. Метод finalize()
2.2.4
Методы классов, сигнатура методов, передача параметров в метод. Явные и неявные параметры метода (this)
2.2.5
Статические методы и поля, модификаторы final и native
2.2.6
Блоки инициализации. Инициализация полей класса (порядок инициализации)
2.2.7
Перегрузка методов
2.2.8
Класс java.lang.Object. Методы этого класса.
2.2.9
Методы с переменным числом параметров
2.3
Принципы ООП
2.3.1
Абстракция и Инкапсуляция
2.3.2
Наследование
2.3.3
Полиморфизм (виды полиморфизма)
2.3.4
Механизм позднего связывания (overriding)
2.3.5
SOLID принципы
2.4
Наследование
2.4.1
Основные понятия
2.4.2
Переопределение методов
2.4.3
Вызов конструкторов при наследовании
2.4.4
Ссылки на суперкласс и их свойства. Действия, которые происходят при вызове метода, принадлежащего объекту. Предотвращение наследования с помощью модификатора final. Приведение типов при наследовании.
2.4.5
Абстрактные методы и классы.
2.4.6
Статические методы при наследовании
2.5
Interfaces
2.5.1
Назначение
2.5.2
Определение и реализация интерфейса
2.5.3
Свойства интерфейсов
2.5.4
Интерфейсы и обратные вызовы
2.5.5
Клонирование объектов. Интерфейс Clonable
2.5.6
Сравнение объектов. Интерфейс Comparable
Errors & exceptions
3.1
Понятие исключения
3.2
Основные принципы обработки исключений
3.3
Типы исключений
3,4
Использование операторов try и catch
3,5
Множественные операторы catch
3,6
Вложенные операторы try
3,7
Оператор throw и ключевое слово throws
3,8
Блок finally
3,9
Создание собственных исключений
3.9.1
Наследование классов Throwable и Exeption
3.9.2
Методы и конструкторы, определенные в Throwable и Exeption
3.10
Применение собственных исключений
Функциональные интерфейсы
Методы default и static в интерфейсах
Функциональные интерфейсы и лямбда-выражения
Интерфейс Predicate
Интерфейс Function
Интерфейс Consumer
Интерфейс Supplier
Интерфейс Comparator
Замыкания
Ссылки на методы
Stream API
Какие есть методы в интерфейсе Stream?
Чем отличается метод map от flatMap?
Какой функциональный интерфейс использует метод filter?
…
Threads
1. Multithreading
1.1. Понятие потока и процесса
1.2. Создание и запуск потоков. Класс Thread, интерфейсы Runnable, Callable
Существует 3 способа создания и запуска потока, на основе расширения класса Thread, реализация интерфейсов Runnable и Call
1.3. Методы класса Thread
1.4. Thread Lificycle
1.5. Состояния потока
1.6. Приоритетность потоков
2. Daemon threads - используются для работы в фоновом режиме вместе с программой, но не являются неотъемлемой частью логики программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как пото-демон. С  помощью метода setDaemon(boolean value), вызванного вновь созданным потоком до его запуска, можно определить поток-демон.
3. Threads & exceptions. В процессе функционирования потоки являются в общем случае независимыми друг от друга. Прямым следствием такой независимости будет корректное продолжение работы потока main после аварийной остановки запущенного из него потока после генерации исключения.
4. Non blocking concurrency
4.1. volatile обеспечивает неблокирующую синхронизацию.
4.2. Atomic существует целая группа классов, обеспечивающая неблокирующую синхронизацию. Атомарные классы созданы для организации неблокирующих структур данных. Классы атомарных переменных расширят нотацию volatile значений, полей и элементов массивов. 
5.1. method wait
	Метод wait вызывается только внутри синхронизированного блока, он останавливает выполнение текущего потока и освобождает от блокировки текущий объект.
5.2. methods notify notifyAll также вызыва.тся внутри синхронизированного блока. notify продолжает работу потока в котором раньше был вызван wait, notifyAll возобновляет все потоки которые раньше вызвали wait.
5.3. Monitor
	Контроль за доступом к объекту-ресурсу обеспечивает понятие монитора. Монитор экземпляра может быть только одного владельца. при попытке конкурирующего доступа к объекту, чей мониток имеет владельца, желающий заблокировать объект-русурс поток должен подождать освобождения монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.
5.4. Интерфейс Lock как альтернатива synchronized
	Дополнительная гибкая реализация модель реализации синнхронизации.
	Поддерживает ограниченные ожидания снятия блокировки, прерываемые попытки блокировки, очереди блокировки и установку ожидания снятия.
	В то время как synchronized метод блокирует объект, на котором вызван, методы интерфейса Lock блокируют сам объект Lock.
	Интерфейс также оптимизирует работу JVM с процессами конкурирования за освобождаемые ресурсы.
5.5. Deadlock
	При работе с блокировками ресурсов потоков может возникать ситуация deadlock. То есть потоки в своем взаимодействии остановились и никаким образом не могут продолжить свое выполнение. 
1. Паралелльные утилиты
6.1. Semaphore
	Позволяет управлять доступом к ресурсам или просто работой потоков на основе запрещений-разрешений. Семафор всегда устанавливается на положительное число потоков, одновременное функционирование которых может быть разрешено в определенным участке кода. При превышении предельного числа все желающие работать потоки будут приостановлены до освобождения семафора одним из работающих по его разрешению потоков. Уменьшение счетчика доступа производится методами void acquire() и его оболочки boolean teyAcquire(). Метод release() освобождает семафор и увеличивает счетчик на единицу.
6.2. CyclicBarrier
	Класс CyclicBarrier определяет минимальное число потоков, которое может быть остановлено барьером. Кроме того, барьер сам может быть проинициализирован потоком, который будет запускаться при снятии барьера. Методы int await() и int await(long timeout, TimeUnit unit) останавливает поток, использующий барьер, до тех пор пока число потоков не достигнет числа в классе-барьере. Метод await() возвращает порядковый номер достижения потоком барьерной точки. Метод boolean isBroken() проверяет состояние барьера. Метод reset() сбрасывает состояние барьера к моменту инициализации. Метод int getNumberWaiting() позволяет определить число ожидаемых барьером потоков до его снятия. Экземпляр CyclicBarrier можно использовать повторно.
6.3. CountDownLatch
	Экземпляр класса инициализируется начальным значением числа ожидающих снятия "защелки" потоков. В отличие от CyclicBarrier, метод await() просто останавливает поток без каких-либо изменений значения счетчика. Значение счетчика снижается вызовом метода countDown(), т.е. "защелка" сдвигается на единицу.
	Когда счетчик обнулится, барьеры, поставленные методом await(), снимаются для всех ожидающих разрешения потоков.
6.4. BlockingQueue, BlockingDeque
	Это блокирующие очереди, гарантирующие остановку потока, запрашивающего элемент из пустой очереди до появления в ней элемента, доступного для извлечения, а также блокирующего поток, пытающийся вставить элемент в заполненную очередь до тех пор, пока в очереди не освободится позиция.
6.5. Exchanger
	Ситуации с необходимостью обмена объектами при их взаимном блокировании возникают, для решения зазработан класс Exchanger, предоставляющий возможность безопасного обмена объектами, в том числе и синхронизтрованными. 
6.6. Phaser
	Основным назначением Phaser является синхронизация потоков, для выполнения которых требуется разбить их га отдельные этапы(фазы), а эти фазы, в свою очередь, необходимо синхронизировать.
1. TimeUnit
	Представляет различные единицы измерения времени. В TimeUnit реализован ряд методов по преобразованию между единицами измерения и по управлению операциями ожидания в потоках в этих единицах. используется для информирования методов, работающих со временем, о том, как интерпретировать заданный параметр времени.
	Перечисление TimeUnit может представлять время в семи размерностях-значениях: NANOSECONDS, MICROSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS.
	Кроме методов преобразовани яединиц времени представляют интерес методы управления потоками:
		void timedWait(Object obj, long timeout) -  выполняет метод wait(long time) для объекта obj класса Object, используя данные единицы измерения;
		void timedJoin(Thread thread, long timeout) - выполняет метод join(long time) на потоке thread, используя данные единицы измерения.
		void sleep(long timeout) - выполняет метод sleep(long time) класса Thread, используя данные единицы времени.
1. ExecutorService и Механизм Fork\Join
	Механизм испольнителей, функции которого заключаются в запуске отдельных потоков и их групп, а также в управлении ими: принудительной остановке, контроле числа работающих потоков и планирования их запуска.
	Класс ExecutorService методом execute(Runnable thread) запускает традиционные потоки, метод же submit(Callable<T> task) запускает потоки с возвращаемым значением. Метод shutDown() останавливает все запущенные им ранее потоки и прекращает действие самого испольнителя. Статические методы newSingleThreadExecutor() и newFixedThreadPool(int numThreads) класса Executors определяет правила, по которым работает ExecutorService, а именно первй позволяет испольнителю запускать только один поток. а второй - не более чем указано в параметре numThreads, ставя другие потоки в очередь ожидания окончания уже запущенных потоков.
	Интерфейс Callable представляет поток, возвращающий значенрие вызывающему потоку. Определяет один метод V call() throws Exception, в код реализации которого и следует поместить решаемую задачу. Результат выполнения метода call() может быть получен через экземпляр класса Future, методами V get() или V get(long timeout, Timeunit unit). Перед извлечением результатов работы потока Callable можно проверить, завершилась ли задача успешно, методами isDono() и isCancelled().
	